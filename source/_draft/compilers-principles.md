---
title: Note | Compilers Principles, Techniques & Tools
date: 2018-9-10
categories: Note
comments: false
tags:
  - Compiler
  - Design
---

《编译原理》，江湖人称龙书。

<!-- more -->

# 第1章 引论

# 第3章 词法分析

## 3.1 词法分析器的作用

词法分析器的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列。词法分析器还负责过滤掉源程序中的注释和空白，同时将编译器生成的错误消息与源程序的位置联系起来。如果源程序使用了一个宏预处理器，则宏的扩展也可以由词法分析器完成。

词法分析的三个相关但有区别的术语：

* 词法单元：由一个词法单元名和一个可选的属性值组成。
* 模式：描述了一个词法单元的词素可能具有的形式。
* 词素：源程序中的一个字符序列，与某个词法单元的模式匹配，并被词法分析器是被为词法单元的实例。

最简单的错误恢复策略是“恐慌模式”恢复，但是恢复技术会给语法分析器带来混乱。

## 3.2 输入缓冲

利用两个交替读入的缓冲区可以减少用于处理单个输入字符的时间开销。

在缓冲区末端加入“哨兵标志”字符EOF，可以将对缓冲区末端的测试和对当前字符的测试合二为一。

## 3.3 词法单元的规约

正则表达式是一种用来描述词素模式的重要表示方法。

**字母表(alphabet)**是一个有限的符号集合，包括字母、位数和标点符号。集合$\{0, 1\}$是二进制字母表(binary alphabet)，ASCII是字母表的一个重要例子。

以字符为下标的地址来存放各个case的指令地址，可以实现多路分支，处理不同的字符。

**串(string)**是字母表中符号的一个有穷序列，串$s$的长度记作$|s|$。空串是长度为0的串，用$\epsilon$表示。**语言(language)**是某个给定字母表上一个任意的可数的串集合。

|     运算      |               定义和表示                |
| :-----------: | :-------------------------------------: |
|   L和M的并    | $L \cup M = \{ s | s属于L或者s属于M \}$ |
|  L和M的连接   |    $LM = \{ st | s属于L且t属于M \}$     |
| L的Kleene闭包 |     $L^* = \cup_{i=0}^{\infty} L^i$     |
|   L的正闭包   |     $L^+ = \cup_{i=1}^{\infty} L^i$     |

假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：

* $(r)|(s)$是一个正则表达式，表示语言$L(r) \cup L(s)$。
* $(r)(s)$是一个正则表达式，表示语言$L(r)L(s)$。
* $(r)^*$是一个正则表达式，表示语言$(L(r))^*$。
* $(r)$是一个正则表达式，表示语言$L(r)$。

在优先级上，`*`具有最高优先级，连接次之，`|`优先级最低，且三者均为左结合的。

可以用一个正则表达式定义的语言叫做**正则集合(regular set)**。

* `+`：一个或多个实例
* `?`：零个或一个实例
* `[abcd]`：字符类

## 3.4 词法单元的识别

**状态转换图(transition diagram)**有一组被称为“状态”(state)的结点或圆圈，边(edge)从图的一个状态指向另一个状态。某些状态称为接受状态或最终状态。

## 3.5 词法分析器生成工具Lex

Lex，也称为Flex，支持使用正则表达式来描述各个词法单元的模式，由此给出一个词法分析器的规约。Lex通常与Yacc一起使用。

一个Lex程序具有如下形式：

```
声明部分
%%
转换规则
%%
辅助函数
```

声明部分包括变量和明示常量(manifest constant)，每个转换规则有`模式 {动作}`的形式，动作部分是代码片段(为C或其它语言)。

声明部分有特殊的括号对`%{`和`%}`，出现在括号内的所有内容都被直接复制到文件`lex.yy.c`中，不会被当成正则定义处理。

**Lex中冲突的解决**：

* 总是选择最长的前缀。
* 如果最长的可能前缀与多个模式匹配，总是选择在Lex程序中先被列出的模式。

## 3.6 有穷自动机

Lex将输入程序变成一个词法分析器，转换的核心是被称为**有穷自动机(finite automata)**的表示方法。本质上有穷自动机与状态转换图类似，但又下列不同点：

* 有穷自动机是识别器(recognizer)，只能对输入串回答“是”或“否”。
* 有穷自动机分为**不确定的有穷自动机(Nondeterministic Finite Automata, NFA)**、**确定的有穷自动机(Deterministic Finite Automata, DFA)**。

可以将NFA表示为一张**转换表(transition table)**，表的各行对应于状态，各列对应于输入符号和$\epsilon$。

## 3.7 从正则表达式到自动机

**子集构造法**给出了一个直接模拟NFA的算法，其基本思想是让构造得到的DFA的每个状态对应于NFA的一个状态集合。

## 3.8 词法分析器生成工具的设计

模拟NFA运行的过程中，最终会到达一个没有后续状态的输入点。那时，不可能有任何更长的输入前缀使得这个NFA到达某个接受状态，此后的状态集将一直为空。

另一种体系结构，使用子集构造法将表示所有模式的NFA转换为等价的DFA。

## 3.9 基于DFA的模式匹配器的优化

如果一个NFA状态有一个标号非$\epsilon$的离开转换，那么称这个状态为**重要状态(important state)**。请注意，子集构造法在计算$\epsilon-closure(move(T,a))$的时候，它只使用了集合T的重要状态。也就是说，只有当状态s是重要的，状态集合$move(s,a)$才可能是非空的。

在子集构造法的应用过程中，两个NFA状态集合可以被认为是一致的，条件是：

* 具有相同的重要状态。
* 要么都包含接受状态，要么都不包含接受状态。

 # 第4章 语法分析

## 4.1 引论

语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成。

处理文法的语法分析器大体上可以分为三种类型：通用的、自顶向下的、自底向上的。通用方法效率很低，不能用于编译器产品。自顶向下的方法从语法分析树的顶部根结点开始向底部叶子结点构造语法分析树，而自底向上的方法则从叶子结点开始逐渐向根结点方向构造。

```
E -> E + T | T
T -> T * F | F
F -> (E) | id
```

上述表达式文法属于LR文法类，适用于自底向上的语法分析技术。但它不能用于自顶向下的语法分析，因为它是左递归的。下面是无左递归版本。

```
E -> TE'
E' -> + TE'|epsilon
T -> FT'
T' -> * FT'|epsilon
F -> (E) | id
```

* 词法错误：包括标识符、关键词 、运算符拼写错误和没有在字符串文本上正确地加上引号。
* 语法错误：包括分号放错地方、花括号多余或缺失。
* 语义错误：包括运算符和运算分量之间地类型不匹配。
* 逻辑错误：可以是因程序员地错误推理而引起地任何错误。

## 4.2 上下文无关文法

```
stmt -> if (expr) stmt else stmt
```

一个上下文无关文法(简称文法)由终结符号、非终结符号、一个开始符合和一组产生式组成，是一个四元式$G=(V_T, V_N, S, P)$。

* $V_T$是终结符(terminal)集，终结符号是组成串地基本符号，如关键词`if`、`else`和符号`(`、`)`。
* $V_N$是非终结符(nonterminal)集，非终结符号是表示串的集合的语法变量，如`stmt`和`expr`。
* $S$是开始符号，$S \in V_N$。
* $P$是产生式的有限集合，每个产生式形如$A \rightarrow \alpha$，其中$A \in V_N, \alpha \in (V_N \cup V_T)^*$。开始符号至少在某个产生式的左部出现一次。

$E \Rightarrow -E$读作E推导出-E，由产生式$E \rightarrow -E$表明。

## 4.3 设计文法

消除二义性可以用最近匹配原则。

如果一个文法中有一个非终结符号A使得对某个串$\alpha$存在一个推导$A \cdot \Rightarrow A\alpha$，那么这个文法就是**左递归的(left recursive)**。

```
A -> Aa | b

改为：
A -> bA'
A' -> aA'|epsilon
```

一般情况如下：

```
A -> Aa1 | Aa2 | ... | b1 | b2 | ... | bn

改为：
A -> b1A' | b2A' | ... | bnA'
A' -> a1A' | a2A' | ... | amA' | epsilon
```

提取左公因子是一种文法转换方法，它可以产生适用于预测分析技术或自顶向下分析技术的文法。

```
A -> ab1 | ab2 | ... | abn | y

改为：
A -> aA'|y
A' -> b1|b2|...|bn
```

## 4.4 自顶而下的语法分析

一个递归下降语法分析程序由一组过程组成，每个非终结符号有一个对应的过程。程序的执行从开始符号对应的过程开始，如果这个过程的过程体扫描了整个输入串，它就停止执行并宣布语法分析成功完成。

自顶向下和自底向上语法分析器的构造可以使用和文法G相关的两个函数FIRST和FOLLOW来实现。

$FIRST(\alpha)$被定义为可从$\alpha$推导得到的串的首符号的集合，其中$\alpha$是任意的文法符号串。对于非终结符号$A$，$FOLLOW(A)$被定义为可能在某些句型中紧跟在A右边的终结符号的集合。

对于称为$LL(1)$的文法，我们可以构造出预测分析器，即不需要回溯的递归下降语法分析器。$LL(1)$中的第一个L表示从左向右扫描输入，第二个L表示产生最左推导，而1则表示在每一步中只需要向前看一个输入符号来决定语法分析动作。

我们可以构造出一个非递归的预测分析器，它显式地维护一个栈结构，而不是通过递归调用的方式隐式地维护栈。这样的语法分析器可以模拟最左推导的过程。

## 4.5 自底向上的语法分析

一个自底向上的语法分析过程对应于为一个输入串构造语法分析树的过程，它从叶子节点(底部)开始逐渐向上到达根节点(顶部)。

**移入-归约语法分析**是一个自底向上语法分析的通用框架。我们可以将自底向上语法分析过程看成将一个串$\omega$**归约**为文法开始符号的过程。在每个归约(reduction)步骤中，一个与某产生式体相匹配的特定子串被替换为该产生式头部的非终结符号。

移入-归约语法分析使用一个栈来保存文法符号，并用一个输入缓冲区来存放将要进行语法分析的其余符号。

## 4.6 LR语法分析技术介绍：简单LR技术

