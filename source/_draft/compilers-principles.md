---
title: Note | Compilers Principles, Techniques & Tools
date: 2018-9-10
categories: Note
comments: false
tags:
  - Compiler
  - Design
---

《编译原理》，江湖人称龙书。

<!-- more -->

# 第1章 引论

# 第3章 词法分析

## 3.1 词法分析器的作用

词法分析器的主要任务是读入源程序的输入字符、将它们组成词素，生成并输出一个词法单元序列。词法分析器还负责过滤掉源程序中的注释和空白，同时将编译器生成的错误消息与源程序的位置联系起来。如果源程序使用了一个宏预处理器，则宏的扩展也可以由词法分析器完成。

词法分析的三个相关但有区别的术语：

* 词法单元：由一个词法单元名和一个可选的属性值组成。
* 模式：描述了一个词法单元的词素可能具有的形式。
* 词素：源程序中的一个字符序列，与某个词法单元的模式匹配，并被词法分析器是被为词法单元的实例。

最简单的错误恢复策略是“恐慌模式”恢复，但是恢复技术会给语法分析器带来混乱。

## 3.2 输入缓冲

利用两个交替读入的缓冲区可以减少用于处理单个输入字符的时间开销。

在缓冲区末端加入“哨兵标志”字符EOF，可以将对缓冲区末端的测试和对当前字符的测试合二为一。

## 3.3 词法单元的规约

正则表达式是一种用来描述词素模式的重要表示方法。

**字母表(alphabet)**是一个有限的符号集合，包括字母、位数和标点符号。集合$\{0, 1\}$是二进制字母表(binary alphabet)，ASCII是字母表的一个重要例子。

以字符为下标的地址来存放各个case的指令地址，可以实现多路分支，处理不同的字符。

**串(string)**是字母表中符号的一个有穷序列，串$s$的长度记作$|s|$。空串是长度为0的串，用$\epsilon$表示。**语言(language)**是某个给定字母表上一个任意的可数的串集合。

|     运算      |               定义和表示                |
| :-----------: | :-------------------------------------: |
|   L和M的并    | $L \cup M = \{ s | s属于L或者s属于M \}$ |
|  L和M的连接   |    $LM = \{ st | s属于L且t属于M \}$     |
| L的Kleene闭包 |     $L^* = \cup_{i=0}^{\infty} L^i$     |
|   L的正闭包   |     $L^+ = \cup_{i=1}^{\infty} L^i$     |

假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：

* $(r)|(s)$是一个正则表达式，表示语言$L(r) \cup L(s)$。
* $(r)(s)$是一个正则表达式，表示语言$L(r)L(s)$。
* $(r)^*$是一个正则表达式，表示语言$(L(r))^*$。
* $(r)$是一个正则表达式，表示语言$L(r)$。

在优先级上，`*`具有最高优先级，连接次之，`|`优先级最低，且三者均为左结合的。

可以用一个正则表达式定义的语言叫做**正则集合(regular set)**。

* `+`：一个或多个实例
* `?`：零个或一个实例
* `[abcd]`：字符类

## 3.4 词法单元的识别

**状态转换图(transition diagram)**有一组被称为“状态”(state)的结点或圆圈，边(edge)从图的一个状态指向另一个状态。某些状态称为接受状态或最终状态。

## 3.5 词法分析器生成工具Lex

Lex，也称为Flex，支持使用正则表达式来描述各个词法单元的模式，由此给出一个词法分析器的规约。Lex通常与Yacc一起使用。

一个Lex程序具有如下形式：

```
声明部分
%%
转换规则
%%
辅助函数
```

声明部分包括变量和明示常量(manifest constant)，每个转换规则有`模式 {动作}`的形式，动作部分是代码片段(为C或其它语言)。

声明部分有特殊的括号对`%{`和`%}`，出现在括号内的所有内容都被直接复制到文件`lex.yy.c`中，不会被当成正则定义处理。

**Lex中冲突的解决**：

* 总是选择最长的前缀。
* 如果最长的可能前缀与多个模式匹配，总是选择在Lex程序中先被列出的模式。

## 3.6 有穷自动机

Lex将输入程序变成一个词法分析器，转换的核心是被称为**有穷自动机(finite automata)**的表示方法。本质上有穷自动机与状态转换图类似，但又下列不同点：

* 有穷自动机是识别器(recognizer)，只能对输入串回答“是”或“否”。
* 有穷自动机分为**不确定的有穷自动机(Nondeterministic Finite Automata, NFA)**、**确定的有穷自动机(Deterministic Finite Automata, DFA)**。

可以将NFA表示为一张**转换表(transition table)**，表的各行对应于状态，各列对应于输入符号和$\epsilon$。

## 3.7 从正则表达式到自动机

**子集构造法**给出了一个直接模拟NFA的算法，其基本思想是让构造得到的DFA的每个状态对应于NFA的一个状态集合。

## 3.8 词法分析器生成工具的设计

模拟NFA运行的过程中，最终会到达一个没有后续状态的输入点。那时，不可能有任何更长的输入前缀使得这个NFA到达某个接受状态，此后的状态集将一直为空。

另一种体系结构，使用子集构造法将表示所有模式的NFA转换为等价的DFA。

## 3.9 基于DFA的模式匹配器的优化

如果一个NFA状态有一个标号非$\epsilon$的离开转换，那么称这个状态为**重要状态(important state)**。请注意，子集构造法在计算$\epsilon-closure(move(T,a))$的时候，它只使用了集合T的重要状态。也就是说，只有当状态s是重要的，状态集合$move(s,a)$才可能是非空的。

在子集构造法的应用过程中，两个NFA状态集合可以被认为是一致的，条件是：

* 具有相同的重要状态。
* 要么都包含接受状态，要么都不包含接受状态。

 
